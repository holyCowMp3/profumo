"""Callback from LiqPay API payments"""
type Callback {
  _id: ID!
  createdAt: DateTime!
  updatedAt: DateTime!
  acq_id: Int
  action: ENUM_CALLBACK_ACTION
  agent_commission: Int
  amount: Int
  amount_bonus: Int
  amount_credit: Int
  amount_debit: Int
  authcode_credit: String
  authcode_debit: String
  card_token: String
  commission_debit: Int
  commission_credit: Int
  customer: String
  err_code: String
  err_description: String
  ip: String
  liqpay_order_id: String
  order_id: String
  payment_id: String
  paytype: ENUM_CALLBACK_PAYTYPE
  sender_card_mask2: String
  sender_card_type: String
  sender_first_name: String
  sender_last_name: String
  sender_phone: String
  status: ENUM_CALLBACK_STATUS
  token: String
  type: String
  verifycode: String
}

type CallbackAggregator {
  count: Int
  sum: CallbackAggregatorSum
  avg: CallbackAggregatorAvg
  min: CallbackAggregatorMin
  max: CallbackAggregatorMax
}

type CallbackAggregatorAvg {
  acq_id: Float
  agent_commission: Float
  amount: Float
  amount_bonus: Float
  amount_credit: Float
  amount_debit: Float
  commission_debit: Float
  commission_credit: Float
}

type CallbackAggregatorMax {
  acq_id: Float
  agent_commission: Float
  amount: Float
  amount_bonus: Float
  amount_credit: Float
  amount_debit: Float
  commission_debit: Float
  commission_credit: Float
}

type CallbackAggregatorMin {
  acq_id: Float
  agent_commission: Float
  amount: Float
  amount_bonus: Float
  amount_credit: Float
  amount_debit: Float
  commission_debit: Float
  commission_credit: Float
}

type CallbackAggregatorSum {
  acq_id: Float
  agent_commission: Float
  amount: Float
  amount_bonus: Float
  amount_credit: Float
  amount_debit: Float
  commission_debit: Float
  commission_credit: Float
}

type CallbackConnection {
  values: [Callback]
  groupBy: CallbackGroupBy
  aggregate: CallbackAggregator
}

type CallbackConnection_id {
  key: ID
  connection: CallbackConnection
}

type CallbackConnectionAcq_id {
  key: Int
  connection: CallbackConnection
}

type CallbackConnectionAction {
  key: String
  connection: CallbackConnection
}

type CallbackConnectionAgent_commission {
  key: Int
  connection: CallbackConnection
}

type CallbackConnectionAmount {
  key: Int
  connection: CallbackConnection
}

type CallbackConnectionAmount_bonus {
  key: Int
  connection: CallbackConnection
}

type CallbackConnectionAmount_credit {
  key: Int
  connection: CallbackConnection
}

type CallbackConnectionAmount_debit {
  key: Int
  connection: CallbackConnection
}

type CallbackConnectionAuthcode_credit {
  key: String
  connection: CallbackConnection
}

type CallbackConnectionAuthcode_debit {
  key: String
  connection: CallbackConnection
}

type CallbackConnectionCard_token {
  key: String
  connection: CallbackConnection
}

type CallbackConnectionCommission_credit {
  key: Int
  connection: CallbackConnection
}

type CallbackConnectionCommission_debit {
  key: Int
  connection: CallbackConnection
}

type CallbackConnectionCreatedAt {
  key: DateTime
  connection: CallbackConnection
}

type CallbackConnectionCustomer {
  key: String
  connection: CallbackConnection
}

type CallbackConnectionErr_code {
  key: String
  connection: CallbackConnection
}

type CallbackConnectionErr_description {
  key: String
  connection: CallbackConnection
}

type CallbackConnectionIp {
  key: String
  connection: CallbackConnection
}

type CallbackConnectionLiqpay_order_id {
  key: String
  connection: CallbackConnection
}

type CallbackConnectionOrder_id {
  key: String
  connection: CallbackConnection
}

type CallbackConnectionPayment_id {
  key: String
  connection: CallbackConnection
}

type CallbackConnectionPaytype {
  key: String
  connection: CallbackConnection
}

type CallbackConnectionSender_card_mask2 {
  key: String
  connection: CallbackConnection
}

type CallbackConnectionSender_card_type {
  key: String
  connection: CallbackConnection
}

type CallbackConnectionSender_first_name {
  key: String
  connection: CallbackConnection
}

type CallbackConnectionSender_last_name {
  key: String
  connection: CallbackConnection
}

type CallbackConnectionSender_phone {
  key: String
  connection: CallbackConnection
}

type CallbackConnectionStatus {
  key: String
  connection: CallbackConnection
}

type CallbackConnectionToken {
  key: String
  connection: CallbackConnection
}

type CallbackConnectionType {
  key: String
  connection: CallbackConnection
}

type CallbackConnectionUpdatedAt {
  key: DateTime
  connection: CallbackConnection
}

type CallbackConnectionVerifycode {
  key: String
  connection: CallbackConnection
}

type CallbackGroupBy {
  _id: [CallbackConnection_id]
  createdAt: [CallbackConnectionCreatedAt]
  updatedAt: [CallbackConnectionUpdatedAt]
  acq_id: [CallbackConnectionAcq_id]
  action: [CallbackConnectionAction]
  agent_commission: [CallbackConnectionAgent_commission]
  amount: [CallbackConnectionAmount]
  amount_bonus: [CallbackConnectionAmount_bonus]
  amount_credit: [CallbackConnectionAmount_credit]
  amount_debit: [CallbackConnectionAmount_debit]
  authcode_credit: [CallbackConnectionAuthcode_credit]
  authcode_debit: [CallbackConnectionAuthcode_debit]
  card_token: [CallbackConnectionCard_token]
  commission_debit: [CallbackConnectionCommission_debit]
  commission_credit: [CallbackConnectionCommission_credit]
  customer: [CallbackConnectionCustomer]
  err_code: [CallbackConnectionErr_code]
  err_description: [CallbackConnectionErr_description]
  ip: [CallbackConnectionIp]
  liqpay_order_id: [CallbackConnectionLiqpay_order_id]
  order_id: [CallbackConnectionOrder_id]
  payment_id: [CallbackConnectionPayment_id]
  paytype: [CallbackConnectionPaytype]
  sender_card_mask2: [CallbackConnectionSender_card_mask2]
  sender_card_type: [CallbackConnectionSender_card_type]
  sender_first_name: [CallbackConnectionSender_first_name]
  sender_last_name: [CallbackConnectionSender_last_name]
  sender_phone: [CallbackConnectionSender_phone]
  status: [CallbackConnectionStatus]
  token: [CallbackConnectionToken]
  type: [CallbackConnectionType]
  verifycode: [CallbackConnectionVerifycode]
}

input CallbackInput {
  acq_id: Int
  action: ENUM_CALLBACK_ACTION
  agent_commission: Int
  amount: Int
  amount_bonus: Int
  amount_credit: Int
  amount_debit: Int
  authcode_credit: String
  authcode_debit: String
  card_token: String
  commission_debit: Int
  commission_credit: Int
  customer: String
  err_code: String
  err_description: String
  ip: String
  liqpay_order_id: String
  order_id: String
  payment_id: String
  paytype: ENUM_CALLBACK_PAYTYPE
  sender_card_mask2: String
  sender_card_type: String
  sender_first_name: String
  sender_last_name: String
  sender_phone: String
  status: ENUM_CALLBACK_STATUS
  token: String
  type: String
  verifycode: String
}

"""Categories for site, for simple site management"""
type Category {
  _id: ID!
  createdAt: DateTime!
  updatedAt: DateTime!
  desc: String
  product: Product
  child: Category
  name_en: String
  name_ru: String
  name_ua: String
  rozetkacat: Int
  parent(sort: String, limit: Int, start: Int, where: JSON): [Category]
}

type CategoryAggregator {
  count: Int
  sum: CategoryAggregatorSum
  avg: CategoryAggregatorAvg
  min: CategoryAggregatorMin
  max: CategoryAggregatorMax
}

type CategoryAggregatorAvg {
  rozetkacat: Float
}

type CategoryAggregatorMax {
  rozetkacat: Float
}

type CategoryAggregatorMin {
  rozetkacat: Float
}

type CategoryAggregatorSum {
  rozetkacat: Float
}

type CategoryConnection {
  values: [Category]
  groupBy: CategoryGroupBy
  aggregate: CategoryAggregator
}

type CategoryConnection_id {
  key: ID
  connection: CategoryConnection
}

type CategoryConnectionChild {
  key: ID
  connection: CategoryConnection
}

type CategoryConnectionCreatedAt {
  key: DateTime
  connection: CategoryConnection
}

type CategoryConnectionDesc {
  key: String
  connection: CategoryConnection
}

type CategoryConnectionName_en {
  key: String
  connection: CategoryConnection
}

type CategoryConnectionName_ru {
  key: String
  connection: CategoryConnection
}

type CategoryConnectionName_ua {
  key: String
  connection: CategoryConnection
}

type CategoryConnectionProduct {
  key: ID
  connection: CategoryConnection
}

type CategoryConnectionRozetkacat {
  key: Int
  connection: CategoryConnection
}

type CategoryConnectionUpdatedAt {
  key: DateTime
  connection: CategoryConnection
}

type CategoryGroupBy {
  _id: [CategoryConnection_id]
  createdAt: [CategoryConnectionCreatedAt]
  updatedAt: [CategoryConnectionUpdatedAt]
  desc: [CategoryConnectionDesc]
  product: [CategoryConnectionProduct]
  child: [CategoryConnectionChild]
  name_en: [CategoryConnectionName_en]
  name_ru: [CategoryConnectionName_ru]
  name_ua: [CategoryConnectionName_ua]
  rozetkacat: [CategoryConnectionRozetkacat]
}

input CategoryInput {
  desc: String
  product: ID
  child: ID
  parent: [ID]
  name_en: String
  name_ru: String
  name_ua: String
  rozetkacat: Int
}

"""Comments which was written by customers of shop"""
type Comment {
  _id: ID!
  createdAt: DateTime!
  updatedAt: DateTime!
  text: String
  rate: Int
  owner: UsersPermissionsUser
  verified: Boolean
  name: String
  gender: ENUM_COMMENT_GENDER
  response: String
  product: Product
}

type CommentAggregator {
  count: Int
  sum: CommentAggregatorSum
  avg: CommentAggregatorAvg
  min: CommentAggregatorMin
  max: CommentAggregatorMax
}

type CommentAggregatorAvg {
  rate: Float
}

type CommentAggregatorMax {
  rate: Float
}

type CommentAggregatorMin {
  rate: Float
}

type CommentAggregatorSum {
  rate: Float
}

type CommentConnection {
  values: [Comment]
  groupBy: CommentGroupBy
  aggregate: CommentAggregator
}

type CommentConnection_id {
  key: ID
  connection: CommentConnection
}

type CommentConnectionCreatedAt {
  key: DateTime
  connection: CommentConnection
}

type CommentConnectionGender {
  key: String
  connection: CommentConnection
}

type CommentConnectionName {
  key: String
  connection: CommentConnection
}

type CommentConnectionOwner {
  key: ID
  connection: CommentConnection
}

type CommentConnectionProduct {
  key: ID
  connection: CommentConnection
}

type CommentConnectionRate {
  key: Int
  connection: CommentConnection
}

type CommentConnectionResponse {
  key: String
  connection: CommentConnection
}

type CommentConnectionText {
  key: String
  connection: CommentConnection
}

type CommentConnectionUpdatedAt {
  key: DateTime
  connection: CommentConnection
}

type CommentConnectionVerified {
  key: Boolean
  connection: CommentConnection
}

type CommentGroupBy {
  _id: [CommentConnection_id]
  createdAt: [CommentConnectionCreatedAt]
  updatedAt: [CommentConnectionUpdatedAt]
  text: [CommentConnectionText]
  rate: [CommentConnectionRate]
  owner: [CommentConnectionOwner]
  verified: [CommentConnectionVerified]
  name: [CommentConnectionName]
  gender: [CommentConnectionGender]
  response: [CommentConnectionResponse]
  product: [CommentConnectionProduct]
}

input CommentInput {
  text: String
  rate: Int
  owner: ID
  verified: Boolean
  name: String
  gender: ENUM_COMMENT_GENDER
  response: String
  product: ID
}

input createCallbackInput {
  data: CallbackInput
}

type createCallbackPayload {
  callback: Callback
}

input createCategoryInput {
  data: CategoryInput
}

type createCategoryPayload {
  category: Category
}

input createCommentInput {
  data: CommentInput
}

type createCommentPayload {
  comment: Comment
}

input createDiscountInput {
  data: DiscountInput
}

type createDiscountPayload {
  discount: Discount
}

input createOrderInput {
  data: OrderInput
}

type createOrderPayload {
  order: Order
}

input createProductInput {
  data: ProductInput
}

type createProductPayload {
  product: Product
}

input createRoleInput {
  data: RoleInput
}

type createRolePayload {
  role: UsersPermissionsRole
}

input createSlidercontentInput {
  data: SlidercontentInput
}

type createSlidercontentPayload {
  slidercontent: Slidercontent
}

input createUserInput {
  data: UserInput
}

type createUserPayload {
  user: UsersPermissionsUser
}

"""
The `DateTime` scalar represents a date and time following the ISO 8601 standard
"""
scalar DateTime

input deleteCallbackInput {
  where: InputID
}

type deleteCallbackPayload {
  callback: Callback
}

input deleteCategoryInput {
  where: InputID
}

type deleteCategoryPayload {
  category: Category
}

input deleteCommentInput {
  where: InputID
}

type deleteCommentPayload {
  comment: Comment
}

input deleteDiscountInput {
  where: InputID
}

type deleteDiscountPayload {
  discount: Discount
}

input deleteOrderInput {
  where: InputID
}

type deleteOrderPayload {
  order: Order
}

input deleteProductInput {
  where: InputID
}

type deleteProductPayload {
  product: Product
}

input deleteRoleInput {
  where: InputID
}

type deleteRolePayload {
  role: UsersPermissionsRole
}

input deleteSlidercontentInput {
  where: InputID
}

type deleteSlidercontentPayload {
  slidercontent: Slidercontent
}

input deleteUserInput {
  where: InputID
}

type deleteUserPayload {
  user: UsersPermissionsUser
}

"""Discounts linked for the object"""
type Discount {
  _id: ID!
  createdAt: DateTime!
  updatedAt: DateTime!
  name: String
  expiration_date: Int
  percent: Int
  product: Product
}

type DiscountAggregator {
  count: Int
  sum: DiscountAggregatorSum
  avg: DiscountAggregatorAvg
  min: DiscountAggregatorMin
  max: DiscountAggregatorMax
}

type DiscountAggregatorAvg {
  expiration_date: Float
  percent: Float
}

type DiscountAggregatorMax {
  expiration_date: Float
  percent: Float
}

type DiscountAggregatorMin {
  expiration_date: Float
  percent: Float
}

type DiscountAggregatorSum {
  expiration_date: Float
  percent: Float
}

type DiscountConnection {
  values: [Discount]
  groupBy: DiscountGroupBy
  aggregate: DiscountAggregator
}

type DiscountConnection_id {
  key: ID
  connection: DiscountConnection
}

type DiscountConnectionCreatedAt {
  key: DateTime
  connection: DiscountConnection
}

type DiscountConnectionExpiration_date {
  key: Int
  connection: DiscountConnection
}

type DiscountConnectionName {
  key: String
  connection: DiscountConnection
}

type DiscountConnectionPercent {
  key: Int
  connection: DiscountConnection
}

type DiscountConnectionProduct {
  key: ID
  connection: DiscountConnection
}

type DiscountConnectionUpdatedAt {
  key: DateTime
  connection: DiscountConnection
}

type DiscountGroupBy {
  _id: [DiscountConnection_id]
  createdAt: [DiscountConnectionCreatedAt]
  updatedAt: [DiscountConnectionUpdatedAt]
  name: [DiscountConnectionName]
  expiration_date: [DiscountConnectionExpiration_date]
  percent: [DiscountConnectionPercent]
  product: [DiscountConnectionProduct]
}

input DiscountInput {
  name: String
  expiration_date: Int
  percent: Int
  product: ID
}

input editCallbackInput {
  acq_id: Int
  action: ENUM_CALLBACK_ACTION
  agent_commission: Int
  amount: Int
  amount_bonus: Int
  amount_credit: Int
  amount_debit: Int
  authcode_credit: String
  authcode_debit: String
  card_token: String
  commission_debit: Int
  commission_credit: Int
  customer: String
  err_code: String
  err_description: String
  ip: String
  liqpay_order_id: String
  order_id: String
  payment_id: String
  paytype: ENUM_CALLBACK_PAYTYPE
  sender_card_mask2: String
  sender_card_type: String
  sender_first_name: String
  sender_last_name: String
  sender_phone: String
  status: ENUM_CALLBACK_STATUS
  token: String
  type: String
  verifycode: String
}

input editCategoryInput {
  desc: String
  product: ID
  child: ID
  parent: [ID]
  name_en: String
  name_ru: String
  name_ua: String
  rozetkacat: Int
}

input editCommentInput {
  text: String
  rate: Int
  owner: ID
  verified: Boolean
  name: String
  gender: ENUM_COMMENT_GENDER
  response: String
  product: ID
}

input editDiscountInput {
  name: String
  expiration_date: Int
  percent: Int
  product: ID
}

input editFileInput {
  name: String
  hash: String
  sha256: String
  ext: String
  mime: String
  size: String
  url: String
  provider: String
  public_id: String
  related: [ID]
}

input editOrderInput {
  dateOrder: DateTime
  products: [ID]
  owner: ID
  status: ENUM_ORDER_STATUS
}

input editProductInput {
  name_ua: String
  desc: String
  photos: [ID]
  added_at: DateTime
  price: Float
  rating: Int
  category: ID
  sex: ENUM_PRODUCT_SEX
  discounts: ID
  order: ID
  props: JSON
  name_ru: String
  name_en: String
  amount: Int
  rozetka_exp: Boolean
  comments: [ID]
}

input editRoleInput {
  name: String
  description: String
  type: String
  permissions: [ID]
  users: [ID]
}

input editSlidercontentInput {
  name: String
  image: ID
  link: String
}

input editUserInput {
  username: String
  email: String
  provider: String
  password: String
  resetPasswordToken: String
  confirmed: Boolean
  blocked: Boolean
  role: ID
  orders: [ID]
  comments: [ID]
  address: JSON
  name: String
  surname: String
}

enum ENUM_CALLBACK_ACTION {
  pay
  hold
  paysplit
  subscribe
  paydonate
  auth
  regular
}

enum ENUM_CALLBACK_PAYTYPE {
  card
  liqpay
  privat24
  masterpass
  cash
  invoice
  qr
}

enum ENUM_CALLBACK_STATUS {
  error
  failure
  reversed
  sandbox
  subscribed
  success
  unsubscribed
  prepared
  processing
}

enum ENUM_COMMENT_GENDER {
  male
  female
}

enum ENUM_ORDER_STATUS {
  payed
  error
  processing
}

enum ENUM_PRODUCT_SEX {
  male
  female
}

input FileInput {
  name: String!
  hash: String!
  sha256: String
  ext: String
  mime: String!
  size: String!
  url: String!
  provider: String!
  public_id: String
  related: [ID]
}

input InputID {
  id: ID!
}

"""
The `JSON` scalar type represents JSON values as specified by [ECMA-404](http://www.ecma-international.org/publications/files/ECMA-ST/ECMA-404.pdf).
"""
scalar JSON

union Morph = UsersPermissionsMe | UsersPermissionsMeRole | Callback | createCallbackPayload | updateCallbackPayload | deleteCallbackPayload | CallbackConnection | CallbackAggregator | CallbackAggregatorSum | CallbackAggregatorAvg | CallbackAggregatorMin | CallbackAggregatorMax | CallbackGroupBy | CallbackConnection_id | CallbackConnectionCreatedAt | CallbackConnectionUpdatedAt | CallbackConnectionAcq_id | CallbackConnectionAction | CallbackConnectionAgent_commission | CallbackConnectionAmount | CallbackConnectionAmount_bonus | CallbackConnectionAmount_credit | CallbackConnectionAmount_debit | CallbackConnectionAuthcode_credit | CallbackConnectionAuthcode_debit | CallbackConnectionCard_token | CallbackConnectionCommission_debit | CallbackConnectionCommission_credit | CallbackConnectionCustomer | CallbackConnectionErr_code | CallbackConnectionErr_description | CallbackConnectionIp | CallbackConnectionLiqpay_order_id | CallbackConnectionOrder_id | CallbackConnectionPayment_id | CallbackConnectionPaytype | CallbackConnectionSender_card_mask2 | CallbackConnectionSender_card_type | CallbackConnectionSender_first_name | CallbackConnectionSender_last_name | CallbackConnectionSender_phone | CallbackConnectionStatus | CallbackConnectionToken | CallbackConnectionType | CallbackConnectionVerifycode | Category | createCategoryPayload | updateCategoryPayload | deleteCategoryPayload | CategoryConnection | CategoryAggregator | CategoryAggregatorSum | CategoryAggregatorAvg | CategoryAggregatorMin | CategoryAggregatorMax | CategoryGroupBy | CategoryConnection_id | CategoryConnectionCreatedAt | CategoryConnectionUpdatedAt | CategoryConnectionDesc | CategoryConnectionProduct | CategoryConnectionChild | CategoryConnectionName_en | CategoryConnectionName_ru | CategoryConnectionName_ua | CategoryConnectionRozetkacat | Comment | createCommentPayload | updateCommentPayload | deleteCommentPayload | CommentConnection | CommentAggregator | CommentAggregatorSum | CommentAggregatorAvg | CommentAggregatorMin | CommentAggregatorMax | CommentGroupBy | CommentConnection_id | CommentConnectionCreatedAt | CommentConnectionUpdatedAt | CommentConnectionText | CommentConnectionRate | CommentConnectionOwner | CommentConnectionVerified | CommentConnectionName | CommentConnectionGender | CommentConnectionResponse | CommentConnectionProduct | Discount | createDiscountPayload | updateDiscountPayload | deleteDiscountPayload | DiscountConnection | DiscountAggregator | DiscountAggregatorSum | DiscountAggregatorAvg | DiscountAggregatorMin | DiscountAggregatorMax | DiscountGroupBy | DiscountConnection_id | DiscountConnectionCreatedAt | DiscountConnectionUpdatedAt | DiscountConnectionName | DiscountConnectionExpiration_date | DiscountConnectionPercent | DiscountConnectionProduct | Order | createOrderPayload | updateOrderPayload | deleteOrderPayload | OrderConnection | OrderAggregator | OrderGroupBy | OrderConnection_id | OrderConnectionCreatedAt | OrderConnectionUpdatedAt | OrderConnectionDateOrder | OrderConnectionOwner | OrderConnectionStatus | Product | createProductPayload | updateProductPayload | deleteProductPayload | ProductConnection | ProductAggregator | ProductAggregatorSum | ProductAggregatorAvg | ProductAggregatorMin | ProductAggregatorMax | ProductGroupBy | ProductConnection_id | ProductConnectionCreatedAt | ProductConnectionUpdatedAt | ProductConnectionName_ua | ProductConnectionDesc | ProductConnectionAdded_at | ProductConnectionPrice | ProductConnectionRating | ProductConnectionCategory | ProductConnectionSex | ProductConnectionDiscounts | ProductConnectionOrder | ProductConnectionProps | ProductConnectionName_ru | ProductConnectionName_en | ProductConnectionAmount | ProductConnectionRozetka_exp | Slidercontent | createSlidercontentPayload | updateSlidercontentPayload | deleteSlidercontentPayload | SlidercontentConnection | SlidercontentAggregator | SlidercontentGroupBy | SlidercontentConnection_id | SlidercontentConnectionCreatedAt | SlidercontentConnectionUpdatedAt | SlidercontentConnectionName | SlidercontentConnectionImage | SlidercontentConnectionLink | UploadFile | UploadFileConnection | UploadFileAggregator | UploadFileGroupBy | UploadFileConnection_id | UploadFileConnectionCreatedAt | UploadFileConnectionUpdatedAt | UploadFileConnectionName | UploadFileConnectionHash | UploadFileConnectionSha256 | UploadFileConnectionExt | UploadFileConnectionMime | UploadFileConnectionSize | UploadFileConnectionUrl | UploadFileConnectionProvider | UploadFileConnectionPublic_id | UsersPermissionsPermission | UsersPermissionsRole | createRolePayload | updateRolePayload | deleteRolePayload | UsersPermissionsRoleConnection | UsersPermissionsRoleAggregator | UsersPermissionsRoleGroupBy | UsersPermissionsRoleConnection_id | UsersPermissionsRoleConnectionName | UsersPermissionsRoleConnectionDescription | UsersPermissionsRoleConnectionType | UsersPermissionsUser | createUserPayload | updateUserPayload | deleteUserPayload | UsersPermissionsUserConnection | UsersPermissionsUserAggregator | UsersPermissionsUserGroupBy | UsersPermissionsUserConnection_id | UsersPermissionsUserConnectionUsername | UsersPermissionsUserConnectionEmail | UsersPermissionsUserConnectionProvider | UsersPermissionsUserConnectionConfirmed | UsersPermissionsUserConnectionBlocked | UsersPermissionsUserConnectionRole | UsersPermissionsUserConnectionAddress | UsersPermissionsUserConnectionName | UsersPermissionsUserConnectionSurname

type Mutation {
  createCallback(input: createCallbackInput): createCallbackPayload
  updateCallback(input: updateCallbackInput): updateCallbackPayload
  deleteCallback(input: deleteCallbackInput): deleteCallbackPayload
  createCategory(input: createCategoryInput): createCategoryPayload
  updateCategory(input: updateCategoryInput): updateCategoryPayload
  deleteCategory(input: deleteCategoryInput): deleteCategoryPayload
  createComment(input: createCommentInput): createCommentPayload
  updateComment(input: updateCommentInput): updateCommentPayload
  deleteComment(input: deleteCommentInput): deleteCommentPayload
  createDiscount(input: createDiscountInput): createDiscountPayload
  updateDiscount(input: updateDiscountInput): updateDiscountPayload
  deleteDiscount(input: deleteDiscountInput): deleteDiscountPayload
  createOrder(input: createOrderInput): createOrderPayload
  updateOrder(input: updateOrderInput): updateOrderPayload
  deleteOrder(input: deleteOrderInput): deleteOrderPayload
  createProduct(input: createProductInput): createProductPayload
  updateProduct(input: updateProductInput): updateProductPayload
  deleteProduct(input: deleteProductInput): deleteProductPayload
  createSlidercontent(input: createSlidercontentInput): createSlidercontentPayload
  updateSlidercontent(input: updateSlidercontentInput): updateSlidercontentPayload
  deleteSlidercontent(input: deleteSlidercontentInput): deleteSlidercontentPayload

  """Create a new role"""
  createRole(input: createRoleInput): createRolePayload

  """Update an existing role"""
  updateRole(input: updateRoleInput): updateRolePayload

  """Delete an existing role"""
  deleteRole(input: deleteRoleInput): deleteRolePayload

  """Create a new user"""
  createUser(input: createUserInput): createUserPayload

  """Update an existing user"""
  updateUser(input: updateUserInput): updateUserPayload

  """Delete an existing user"""
  deleteUser(input: deleteUserInput): deleteUserPayload
  upload(refId: ID, ref: String, source: String, file: Upload!): UploadFile!
}

"""Order for clients"""
type Order {
  _id: ID!
  createdAt: DateTime!
  updatedAt: DateTime!
  dateOrder: DateTime
  owner: UsersPermissionsUser
  status: ENUM_ORDER_STATUS
  products(sort: String, limit: Int, start: Int, where: JSON): [Product]
}

type OrderAggregator {
  count: Int
}

type OrderConnection {
  values: [Order]
  groupBy: OrderGroupBy
  aggregate: OrderAggregator
}

type OrderConnection_id {
  key: ID
  connection: OrderConnection
}

type OrderConnectionCreatedAt {
  key: DateTime
  connection: OrderConnection
}

type OrderConnectionDateOrder {
  key: DateTime
  connection: OrderConnection
}

type OrderConnectionOwner {
  key: ID
  connection: OrderConnection
}

type OrderConnectionStatus {
  key: String
  connection: OrderConnection
}

type OrderConnectionUpdatedAt {
  key: DateTime
  connection: OrderConnection
}

type OrderGroupBy {
  _id: [OrderConnection_id]
  createdAt: [OrderConnectionCreatedAt]
  updatedAt: [OrderConnectionUpdatedAt]
  dateOrder: [OrderConnectionDateOrder]
  owner: [OrderConnectionOwner]
  status: [OrderConnectionStatus]
}

input OrderInput {
  dateOrder: DateTime
  products: [ID]
  owner: ID
  status: ENUM_ORDER_STATUS
}

"""Product model which describe main fields of product."""
type Product {
  _id: ID!
  createdAt: DateTime!
  updatedAt: DateTime!
  name_ua: String
  desc: String
  added_at: DateTime
  price: Float
  rating: Int
  category: Category
  sex: ENUM_PRODUCT_SEX
  discounts: Discount
  order: Order
  props: JSON
  name_ru: String
  name_en: String
  amount: Int
  rozetka_exp: Boolean
  photos(sort: String, limit: Int, start: Int, where: JSON): [UploadFile]
  comments(sort: String, limit: Int, start: Int, where: JSON): [Comment]
}

type ProductAggregator {
  count: Int
  sum: ProductAggregatorSum
  avg: ProductAggregatorAvg
  min: ProductAggregatorMin
  max: ProductAggregatorMax
}

type ProductAggregatorAvg {
  price: Float
  rating: Float
  amount: Float
}

type ProductAggregatorMax {
  price: Float
  rating: Float
  amount: Float
}

type ProductAggregatorMin {
  price: Float
  rating: Float
  amount: Float
}

type ProductAggregatorSum {
  price: Float
  rating: Float
  amount: Float
}

type ProductConnection {
  values: [Product]
  groupBy: ProductGroupBy
  aggregate: ProductAggregator
}

type ProductConnection_id {
  key: ID
  connection: ProductConnection
}

type ProductConnectionAdded_at {
  key: DateTime
  connection: ProductConnection
}

type ProductConnectionAmount {
  key: Int
  connection: ProductConnection
}

type ProductConnectionCategory {
  key: ID
  connection: ProductConnection
}

type ProductConnectionCreatedAt {
  key: DateTime
  connection: ProductConnection
}

type ProductConnectionDesc {
  key: String
  connection: ProductConnection
}

type ProductConnectionDiscounts {
  key: ID
  connection: ProductConnection
}

type ProductConnectionName_en {
  key: String
  connection: ProductConnection
}

type ProductConnectionName_ru {
  key: String
  connection: ProductConnection
}

type ProductConnectionName_ua {
  key: String
  connection: ProductConnection
}

type ProductConnectionOrder {
  key: ID
  connection: ProductConnection
}

type ProductConnectionPrice {
  key: Float
  connection: ProductConnection
}

type ProductConnectionProps {
  key: JSON
  connection: ProductConnection
}

type ProductConnectionRating {
  key: Int
  connection: ProductConnection
}

type ProductConnectionRozetka_exp {
  key: Boolean
  connection: ProductConnection
}

type ProductConnectionSex {
  key: String
  connection: ProductConnection
}

type ProductConnectionUpdatedAt {
  key: DateTime
  connection: ProductConnection
}

type ProductGroupBy {
  _id: [ProductConnection_id]
  createdAt: [ProductConnectionCreatedAt]
  updatedAt: [ProductConnectionUpdatedAt]
  name_ua: [ProductConnectionName_ua]
  desc: [ProductConnectionDesc]
  added_at: [ProductConnectionAdded_at]
  price: [ProductConnectionPrice]
  rating: [ProductConnectionRating]
  category: [ProductConnectionCategory]
  sex: [ProductConnectionSex]
  discounts: [ProductConnectionDiscounts]
  order: [ProductConnectionOrder]
  props: [ProductConnectionProps]
  name_ru: [ProductConnectionName_ru]
  name_en: [ProductConnectionName_en]
  amount: [ProductConnectionAmount]
  rozetka_exp: [ProductConnectionRozetka_exp]
}

input ProductInput {
  name_ua: String
  desc: String
  photos: [ID]
  added_at: DateTime
  price: Float
  rating: Int
  category: ID
  sex: ENUM_PRODUCT_SEX
  discounts: ID
  order: ID
  props: JSON
  name_ru: String
  name_en: String
  amount: Int
  rozetka_exp: Boolean
  comments: [ID]
}

type Query {
  callback(id: ID!): Callback
  callbacks(sort: String, limit: Int, start: Int, where: JSON): [Callback]
  callbacksConnection(sort: String, limit: Int, start: Int, where: JSON): CallbackConnection
  category(id: ID!): Category
  categories(sort: String, limit: Int, start: Int, where: JSON): [Category]
  categoriesConnection(sort: String, limit: Int, start: Int, where: JSON): CategoryConnection
  comment(id: ID!): Comment
  comments(sort: String, limit: Int, start: Int, where: JSON): [Comment]
  commentsConnection(sort: String, limit: Int, start: Int, where: JSON): CommentConnection
  discount(id: ID!): Discount
  discounts(sort: String, limit: Int, start: Int, where: JSON): [Discount]
  discountsConnection(sort: String, limit: Int, start: Int, where: JSON): DiscountConnection
  order(id: ID!): Order
  orders(sort: String, limit: Int, start: Int, where: JSON): [Order]
  ordersConnection(sort: String, limit: Int, start: Int, where: JSON): OrderConnection
  product(id: ID!): Product
  products(sort: String, limit: Int, start: Int, where: JSON): [Product]
  productsConnection(sort: String, limit: Int, start: Int, where: JSON): ProductConnection
  slidercontent(id: ID!): Slidercontent
  slidercontents(sort: String, limit: Int, start: Int, where: JSON): [Slidercontent]
  slidercontentsConnection(sort: String, limit: Int, start: Int, where: JSON): SlidercontentConnection
  files(sort: String, limit: Int, start: Int, where: JSON): [UploadFile]
  filesConnection(sort: String, limit: Int, start: Int, where: JSON): UploadFileConnection
  role(id: ID!): UsersPermissionsRole

  """
  Retrieve all the existing roles. You can't apply filters on this query.
  """
  roles(sort: String, limit: Int, start: Int, where: JSON): [UsersPermissionsRole]
  rolesConnection(sort: String, limit: Int, start: Int, where: JSON): UsersPermissionsRoleConnection
  user(id: ID!): UsersPermissionsUser
  users(sort: String, limit: Int, start: Int, where: JSON): [UsersPermissionsUser]
  usersConnection(sort: String, limit: Int, start: Int, where: JSON): UsersPermissionsUserConnection
  me: UsersPermissionsMe
}

input RoleInput {
  name: String!
  description: String
  type: String
  permissions: [ID]
  users: [ID]
}

type Slidercontent {
  _id: ID!
  createdAt: DateTime!
  updatedAt: DateTime!
  name: String
  image: UploadFile
  link: String
}

type SlidercontentAggregator {
  count: Int
}

type SlidercontentConnection {
  values: [Slidercontent]
  groupBy: SlidercontentGroupBy
  aggregate: SlidercontentAggregator
}

type SlidercontentConnection_id {
  key: ID
  connection: SlidercontentConnection
}

type SlidercontentConnectionCreatedAt {
  key: DateTime
  connection: SlidercontentConnection
}

type SlidercontentConnectionImage {
  key: ID
  connection: SlidercontentConnection
}

type SlidercontentConnectionLink {
  key: String
  connection: SlidercontentConnection
}

type SlidercontentConnectionName {
  key: String
  connection: SlidercontentConnection
}

type SlidercontentConnectionUpdatedAt {
  key: DateTime
  connection: SlidercontentConnection
}

type SlidercontentGroupBy {
  _id: [SlidercontentConnection_id]
  createdAt: [SlidercontentConnectionCreatedAt]
  updatedAt: [SlidercontentConnectionUpdatedAt]
  name: [SlidercontentConnectionName]
  image: [SlidercontentConnectionImage]
  link: [SlidercontentConnectionLink]
}

input SlidercontentInput {
  name: String
  image: ID
  link: String
}

input updateCallbackInput {
  where: InputID
  data: editCallbackInput
}

type updateCallbackPayload {
  callback: Callback
}

input updateCategoryInput {
  where: InputID
  data: editCategoryInput
}

type updateCategoryPayload {
  category: Category
}

input updateCommentInput {
  where: InputID
  data: editCommentInput
}

type updateCommentPayload {
  comment: Comment
}

input updateDiscountInput {
  where: InputID
  data: editDiscountInput
}

type updateDiscountPayload {
  discount: Discount
}

input updateOrderInput {
  where: InputID
  data: editOrderInput
}

type updateOrderPayload {
  order: Order
}

input updateProductInput {
  where: InputID
  data: editProductInput
}

type updateProductPayload {
  product: Product
}

input updateRoleInput {
  where: InputID
  data: editRoleInput
}

type updateRolePayload {
  role: UsersPermissionsRole
}

input updateSlidercontentInput {
  where: InputID
  data: editSlidercontentInput
}

type updateSlidercontentPayload {
  slidercontent: Slidercontent
}

input updateUserInput {
  where: InputID
  data: editUserInput
}

type updateUserPayload {
  user: UsersPermissionsUser
}

"""The `Upload` scalar type represents a file upload."""
scalar Upload

type UploadFile {
  _id: ID!
  createdAt: DateTime!
  updatedAt: DateTime!
  name: String!
  hash: String!
  sha256: String
  ext: String
  mime: String!
  size: String!
  url: String!
  provider: String!
  public_id: String
  related(sort: String, limit: Int, start: Int, where: JSON): [Morph]
}

type UploadFileAggregator {
  count: Int
}

type UploadFileConnection {
  values: [UploadFile]
  groupBy: UploadFileGroupBy
  aggregate: UploadFileAggregator
}

type UploadFileConnection_id {
  key: ID
  connection: UploadFileConnection
}

type UploadFileConnectionCreatedAt {
  key: DateTime
  connection: UploadFileConnection
}

type UploadFileConnectionExt {
  key: String
  connection: UploadFileConnection
}

type UploadFileConnectionHash {
  key: String
  connection: UploadFileConnection
}

type UploadFileConnectionMime {
  key: String
  connection: UploadFileConnection
}

type UploadFileConnectionName {
  key: String
  connection: UploadFileConnection
}

type UploadFileConnectionProvider {
  key: String
  connection: UploadFileConnection
}

type UploadFileConnectionPublic_id {
  key: String
  connection: UploadFileConnection
}

type UploadFileConnectionSha256 {
  key: String
  connection: UploadFileConnection
}

type UploadFileConnectionSize {
  key: String
  connection: UploadFileConnection
}

type UploadFileConnectionUpdatedAt {
  key: DateTime
  connection: UploadFileConnection
}

type UploadFileConnectionUrl {
  key: String
  connection: UploadFileConnection
}

type UploadFileGroupBy {
  _id: [UploadFileConnection_id]
  createdAt: [UploadFileConnectionCreatedAt]
  updatedAt: [UploadFileConnectionUpdatedAt]
  name: [UploadFileConnectionName]
  hash: [UploadFileConnectionHash]
  sha256: [UploadFileConnectionSha256]
  ext: [UploadFileConnectionExt]
  mime: [UploadFileConnectionMime]
  size: [UploadFileConnectionSize]
  url: [UploadFileConnectionUrl]
  provider: [UploadFileConnectionProvider]
  public_id: [UploadFileConnectionPublic_id]
}

input UserInput {
  username: String!
  email: String!
  provider: String
  password: String
  resetPasswordToken: String
  confirmed: Boolean
  blocked: Boolean
  role: ID
  orders: [ID]
  comments: [ID]
  address: JSON
  name: String
  surname: String
}

type UsersPermissionsMe {
  _id: ID!
  username: String!
  email: String!
  confirmed: Boolean
  blocked: Boolean
  role: UsersPermissionsMeRole
}

type UsersPermissionsMeRole {
  _id: ID!
  name: String!
  description: String
  type: String
}

type UsersPermissionsPermission {
  _id: ID!
  type: String!
  controller: String!
  action: String!
  enabled: Boolean!
  policy: String
  role: UsersPermissionsRole
}

type UsersPermissionsRole {
  _id: ID!
  name: String!
  description: String
  type: String
  permissions(sort: String, limit: Int, start: Int, where: JSON): [UsersPermissionsPermission]
  users(sort: String, limit: Int, start: Int, where: JSON): [UsersPermissionsUser]
}

type UsersPermissionsRoleAggregator {
  count: Int
}

type UsersPermissionsRoleConnection {
  values: [UsersPermissionsRole]
  groupBy: UsersPermissionsRoleGroupBy
  aggregate: UsersPermissionsRoleAggregator
}

type UsersPermissionsRoleConnection_id {
  key: ID
  connection: UsersPermissionsRoleConnection
}

type UsersPermissionsRoleConnectionDescription {
  key: String
  connection: UsersPermissionsRoleConnection
}

type UsersPermissionsRoleConnectionName {
  key: String
  connection: UsersPermissionsRoleConnection
}

type UsersPermissionsRoleConnectionType {
  key: String
  connection: UsersPermissionsRoleConnection
}

type UsersPermissionsRoleGroupBy {
  _id: [UsersPermissionsRoleConnection_id]
  name: [UsersPermissionsRoleConnectionName]
  description: [UsersPermissionsRoleConnectionDescription]
  type: [UsersPermissionsRoleConnectionType]
}

type UsersPermissionsUser {
  _id: ID!
  username: String!
  email: String!
  provider: String
  confirmed: Boolean
  blocked: Boolean
  role: UsersPermissionsRole
  address: JSON
  name: String
  surname: String
  orders(sort: String, limit: Int, start: Int, where: JSON): [Order]
  comments(sort: String, limit: Int, start: Int, where: JSON): [Comment]
}

type UsersPermissionsUserAggregator {
  count: Int
}

type UsersPermissionsUserConnection {
  values: [UsersPermissionsUser]
  groupBy: UsersPermissionsUserGroupBy
  aggregate: UsersPermissionsUserAggregator
}

type UsersPermissionsUserConnection_id {
  key: ID
  connection: UsersPermissionsUserConnection
}

type UsersPermissionsUserConnectionAddress {
  key: JSON
  connection: UsersPermissionsUserConnection
}

type UsersPermissionsUserConnectionBlocked {
  key: Boolean
  connection: UsersPermissionsUserConnection
}

type UsersPermissionsUserConnectionConfirmed {
  key: Boolean
  connection: UsersPermissionsUserConnection
}

type UsersPermissionsUserConnectionEmail {
  key: String
  connection: UsersPermissionsUserConnection
}

type UsersPermissionsUserConnectionName {
  key: String
  connection: UsersPermissionsUserConnection
}

type UsersPermissionsUserConnectionProvider {
  key: String
  connection: UsersPermissionsUserConnection
}

type UsersPermissionsUserConnectionRole {
  key: ID
  connection: UsersPermissionsUserConnection
}

type UsersPermissionsUserConnectionSurname {
  key: String
  connection: UsersPermissionsUserConnection
}

type UsersPermissionsUserConnectionUsername {
  key: String
  connection: UsersPermissionsUserConnection
}

type UsersPermissionsUserGroupBy {
  _id: [UsersPermissionsUserConnection_id]
  username: [UsersPermissionsUserConnectionUsername]
  email: [UsersPermissionsUserConnectionEmail]
  provider: [UsersPermissionsUserConnectionProvider]
  confirmed: [UsersPermissionsUserConnectionConfirmed]
  blocked: [UsersPermissionsUserConnectionBlocked]
  role: [UsersPermissionsUserConnectionRole]
  address: [UsersPermissionsUserConnectionAddress]
  name: [UsersPermissionsUserConnectionName]
  surname: [UsersPermissionsUserConnectionSurname]
}
