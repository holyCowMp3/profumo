"""Categories for site, for simple site management"""
type Category {
  _id: ID!
  createdAt: DateTime!
  updatedAt: DateTime!
  name: String
  desc: String
  product: Product
}

type CategoryAggregator {
  count: Int
}

type CategoryConnection {
  values: [Category]
  groupBy: CategoryGroupBy
  aggregate: CategoryAggregator
}

type CategoryConnection_id {
  key: ID
  connection: CategoryConnection
}

type CategoryConnectionCreatedAt {
  key: DateTime
  connection: CategoryConnection
}

type CategoryConnectionDesc {
  key: String
  connection: CategoryConnection
}

type CategoryConnectionName {
  key: String
  connection: CategoryConnection
}

type CategoryConnectionProduct {
  key: ID
  connection: CategoryConnection
}

type CategoryConnectionUpdatedAt {
  key: DateTime
  connection: CategoryConnection
}

type CategoryGroupBy {
  _id: [CategoryConnection_id]
  createdAt: [CategoryConnectionCreatedAt]
  updatedAt: [CategoryConnectionUpdatedAt]
  name: [CategoryConnectionName]
  desc: [CategoryConnectionDesc]
  product: [CategoryConnectionProduct]
}

input CategoryInput {
  name: String
  desc: String
  product: ID
}

"""Comments which was written by customers of shop"""
type Comment {
  _id: ID!
  createdAt: DateTime!
  updatedAt: DateTime!
  text: String
  rate: Int
  date: DateTime
  user: UsersPermissionsUser
}

type CommentAggregator {
  count: Int
  sum: CommentAggregatorSum
  avg: CommentAggregatorAvg
  min: CommentAggregatorMin
  max: CommentAggregatorMax
}

type CommentAggregatorAvg {
  rate: Float
}

type CommentAggregatorMax {
  rate: Float
}

type CommentAggregatorMin {
  rate: Float
}

type CommentAggregatorSum {
  rate: Float
}

type CommentConnection {
  values: [Comment]
  groupBy: CommentGroupBy
  aggregate: CommentAggregator
}

type CommentConnection_id {
  key: ID
  connection: CommentConnection
}

type CommentConnectionCreatedAt {
  key: DateTime
  connection: CommentConnection
}

type CommentConnectionDate {
  key: DateTime
  connection: CommentConnection
}

type CommentConnectionRate {
  key: Int
  connection: CommentConnection
}

type CommentConnectionText {
  key: String
  connection: CommentConnection
}

type CommentConnectionUpdatedAt {
  key: DateTime
  connection: CommentConnection
}

type CommentConnectionUser {
  key: ID
  connection: CommentConnection
}

type CommentGroupBy {
  _id: [CommentConnection_id]
  createdAt: [CommentConnectionCreatedAt]
  updatedAt: [CommentConnectionUpdatedAt]
  text: [CommentConnectionText]
  rate: [CommentConnectionRate]
  date: [CommentConnectionDate]
  user: [CommentConnectionUser]
}

input CommentInput {
  text: String
  rate: Int
  date: DateTime
  user: ID
}

input createCategoryInput {
  data: CategoryInput
}

type createCategoryPayload {
  category: Category
}

input createCommentInput {
  data: CommentInput
}

type createCommentPayload {
  comment: Comment
}

input createDiscountInput {
  data: DiscountInput
}

type createDiscountPayload {
  discount: Discount
}

input createOrderInput {
  data: OrderInput
}

type createOrderPayload {
  order: Order
}

input createProductInput {
  data: ProductInput
}

type createProductPayload {
  product: Product
}

input createRoleInput {
  data: RoleInput
}

type createRolePayload {
  role: UsersPermissionsRole
}

input createSlidercontentInput {
  data: SlidercontentInput
}

type createSlidercontentPayload {
  slidercontent: Slidercontent
}

input createUserInput {
  data: UserInput
}

type createUserPayload {
  user: UsersPermissionsUser
}

"""
The `DateTime` scalar represents a date and time following the ISO 8601 standard
"""
scalar DateTime

input deleteCategoryInput {
  where: InputID
}

type deleteCategoryPayload {
  category: Category
}

input deleteCommentInput {
  where: InputID
}

type deleteCommentPayload {
  comment: Comment
}

input deleteDiscountInput {
  where: InputID
}

type deleteDiscountPayload {
  discount: Discount
}

input deleteOrderInput {
  where: InputID
}

type deleteOrderPayload {
  order: Order
}

input deleteProductInput {
  where: InputID
}

type deleteProductPayload {
  product: Product
}

input deleteRoleInput {
  where: InputID
}

type deleteRolePayload {
  role: UsersPermissionsRole
}

input deleteSlidercontentInput {
  where: InputID
}

type deleteSlidercontentPayload {
  slidercontent: Slidercontent
}

input deleteUserInput {
  where: InputID
}

type deleteUserPayload {
  user: UsersPermissionsUser
}

"""Discounts linked for the object"""
type Discount {
  _id: ID!
  createdAt: DateTime!
  updatedAt: DateTime!
  name: String
  expiration_date: Int
  percent: Int
  product: Product
}

type DiscountAggregator {
  count: Int
  sum: DiscountAggregatorSum
  avg: DiscountAggregatorAvg
  min: DiscountAggregatorMin
  max: DiscountAggregatorMax
}

type DiscountAggregatorAvg {
  expiration_date: Float
  percent: Float
}

type DiscountAggregatorMax {
  expiration_date: Float
  percent: Float
}

type DiscountAggregatorMin {
  expiration_date: Float
  percent: Float
}

type DiscountAggregatorSum {
  expiration_date: Float
  percent: Float
}

type DiscountConnection {
  values: [Discount]
  groupBy: DiscountGroupBy
  aggregate: DiscountAggregator
}

type DiscountConnection_id {
  key: ID
  connection: DiscountConnection
}

type DiscountConnectionCreatedAt {
  key: DateTime
  connection: DiscountConnection
}

type DiscountConnectionExpiration_date {
  key: Int
  connection: DiscountConnection
}

type DiscountConnectionName {
  key: String
  connection: DiscountConnection
}

type DiscountConnectionPercent {
  key: Int
  connection: DiscountConnection
}

type DiscountConnectionProduct {
  key: ID
  connection: DiscountConnection
}

type DiscountConnectionUpdatedAt {
  key: DateTime
  connection: DiscountConnection
}

type DiscountGroupBy {
  _id: [DiscountConnection_id]
  createdAt: [DiscountConnectionCreatedAt]
  updatedAt: [DiscountConnectionUpdatedAt]
  name: [DiscountConnectionName]
  expiration_date: [DiscountConnectionExpiration_date]
  percent: [DiscountConnectionPercent]
  product: [DiscountConnectionProduct]
}

input DiscountInput {
  name: String
  expiration_date: Int
  percent: Int
  product: ID
}

input editCategoryInput {
  name: String
  desc: String
  product: ID
}

input editCommentInput {
  text: String
  rate: Int
  date: DateTime
  user: ID
}

input editDiscountInput {
  name: String
  expiration_date: Int
  percent: Int
  product: ID
}

input editFileInput {
  name: String
  hash: String
  sha256: String
  ext: String
  mime: String
  size: String
  url: String
  provider: String
  public_id: String
  related: [ID]
}

input editOrderInput {
  dateOrder: DateTime
  products: [ID]
  user: ID
  status: ENUM_ORDER_STATUS
}

input editProductInput {
  name: String
  desc: String
  photos: [ID]
  added_at: DateTime
  price: Float
  rating: Int
  available: Boolean
  category: ID
  sex: ENUM_PRODUCT_SEX
  discounts: ID
  order: ID
  props: JSON
}

input editRoleInput {
  name: String
  description: String
  type: String
  permissions: [ID]
  users: [ID]
}

input editSlidercontentInput {
  name: String
  image: ID
  link: String
}

input editUserInput {
  username: String
  email: String
  provider: String
  password: String
  resetPasswordToken: String
  confirmed: Boolean
  blocked: Boolean
  role: ID
  order: [ID]
  comment: ID
  address: JSON
  name: String
  surname: String
}

enum ENUM_ORDER_STATUS {
  payed
  error
  processing
}

enum ENUM_PRODUCT_SEX {
  male
  female
}

input FileInput {
  name: String!
  hash: String!
  sha256: String
  ext: String
  mime: String!
  size: String!
  url: String!
  provider: String!
  public_id: String
  related: [ID]
}

input InputID {
  id: ID!
}

"""
The `JSON` scalar type represents JSON values as specified by [ECMA-404](http://www.ecma-international.org/publications/files/ECMA-ST/ECMA-404.pdf).
"""
scalar JSON

union Morph = UsersPermissionsMe | UsersPermissionsMeRole | Category | createCategoryPayload | updateCategoryPayload | deleteCategoryPayload | CategoryConnection | CategoryAggregator | CategoryGroupBy | CategoryConnection_id | CategoryConnectionCreatedAt | CategoryConnectionUpdatedAt | CategoryConnectionName | CategoryConnectionDesc | CategoryConnectionProduct | Comment | createCommentPayload | updateCommentPayload | deleteCommentPayload | CommentConnection | CommentAggregator | CommentAggregatorSum | CommentAggregatorAvg | CommentAggregatorMin | CommentAggregatorMax | CommentGroupBy | CommentConnection_id | CommentConnectionCreatedAt | CommentConnectionUpdatedAt | CommentConnectionText | CommentConnectionRate | CommentConnectionDate | CommentConnectionUser | Discount | createDiscountPayload | updateDiscountPayload | deleteDiscountPayload | DiscountConnection | DiscountAggregator | DiscountAggregatorSum | DiscountAggregatorAvg | DiscountAggregatorMin | DiscountAggregatorMax | DiscountGroupBy | DiscountConnection_id | DiscountConnectionCreatedAt | DiscountConnectionUpdatedAt | DiscountConnectionName | DiscountConnectionExpiration_date | DiscountConnectionPercent | DiscountConnectionProduct | Order | createOrderPayload | updateOrderPayload | deleteOrderPayload | OrderConnection | OrderAggregator | OrderGroupBy | OrderConnection_id | OrderConnectionCreatedAt | OrderConnectionUpdatedAt | OrderConnectionDateOrder | OrderConnectionUser | OrderConnectionStatus | Product | createProductPayload | updateProductPayload | deleteProductPayload | ProductConnection | ProductAggregator | ProductAggregatorSum | ProductAggregatorAvg | ProductAggregatorMin | ProductAggregatorMax | ProductGroupBy | ProductConnection_id | ProductConnectionCreatedAt | ProductConnectionUpdatedAt | ProductConnectionName | ProductConnectionDesc | ProductConnectionAdded_at | ProductConnectionPrice | ProductConnectionRating | ProductConnectionAvailable | ProductConnectionCategory | ProductConnectionSex | ProductConnectionDiscounts | ProductConnectionOrder | ProductConnectionProps | Slidercontent | createSlidercontentPayload | updateSlidercontentPayload | deleteSlidercontentPayload | SlidercontentConnection | SlidercontentAggregator | SlidercontentGroupBy | SlidercontentConnection_id | SlidercontentConnectionCreatedAt | SlidercontentConnectionUpdatedAt | SlidercontentConnectionName | SlidercontentConnectionImage | SlidercontentConnectionLink | UploadFile | UploadFileConnection | UploadFileAggregator | UploadFileGroupBy | UploadFileConnection_id | UploadFileConnectionCreatedAt | UploadFileConnectionUpdatedAt | UploadFileConnectionName | UploadFileConnectionHash | UploadFileConnectionSha256 | UploadFileConnectionExt | UploadFileConnectionMime | UploadFileConnectionSize | UploadFileConnectionUrl | UploadFileConnectionProvider | UploadFileConnectionPublic_id | UsersPermissionsPermission | UsersPermissionsRole | createRolePayload | updateRolePayload | deleteRolePayload | UsersPermissionsRoleConnection | UsersPermissionsRoleAggregator | UsersPermissionsRoleGroupBy | UsersPermissionsRoleConnection_id | UsersPermissionsRoleConnectionName | UsersPermissionsRoleConnectionDescription | UsersPermissionsRoleConnectionType | UsersPermissionsUser | createUserPayload | updateUserPayload | deleteUserPayload | UsersPermissionsUserConnection | UsersPermissionsUserAggregator | UsersPermissionsUserGroupBy | UsersPermissionsUserConnection_id | UsersPermissionsUserConnectionUsername | UsersPermissionsUserConnectionEmail | UsersPermissionsUserConnectionProvider | UsersPermissionsUserConnectionConfirmed | UsersPermissionsUserConnectionBlocked | UsersPermissionsUserConnectionRole | UsersPermissionsUserConnectionComment | UsersPermissionsUserConnectionAddress | UsersPermissionsUserConnectionName | UsersPermissionsUserConnectionSurname

type Mutation {
  createCategory(input: createCategoryInput): createCategoryPayload
  updateCategory(input: updateCategoryInput): updateCategoryPayload
  deleteCategory(input: deleteCategoryInput): deleteCategoryPayload
  createComment(input: createCommentInput): createCommentPayload
  updateComment(input: updateCommentInput): updateCommentPayload
  deleteComment(input: deleteCommentInput): deleteCommentPayload
  createDiscount(input: createDiscountInput): createDiscountPayload
  updateDiscount(input: updateDiscountInput): updateDiscountPayload
  deleteDiscount(input: deleteDiscountInput): deleteDiscountPayload
  createOrder(input: createOrderInput): createOrderPayload
  updateOrder(input: updateOrderInput): updateOrderPayload
  deleteOrder(input: deleteOrderInput): deleteOrderPayload
  createProduct(input: createProductInput): createProductPayload
  updateProduct(input: updateProductInput): updateProductPayload
  deleteProduct(input: deleteProductInput): deleteProductPayload
  createSlidercontent(input: createSlidercontentInput): createSlidercontentPayload
  updateSlidercontent(input: updateSlidercontentInput): updateSlidercontentPayload
  deleteSlidercontent(input: deleteSlidercontentInput): deleteSlidercontentPayload

  """Create a new role"""
  createRole(input: createRoleInput): createRolePayload

  """Update an existing role"""
  updateRole(input: updateRoleInput): updateRolePayload

  """Delete an existing role"""
  deleteRole(input: deleteRoleInput): deleteRolePayload

  """Create a new user"""
  createUser(input: createUserInput): createUserPayload

  """Update an existing user"""
  updateUser(input: updateUserInput): updateUserPayload

  """Delete an existing user"""
  deleteUser(input: deleteUserInput): deleteUserPayload
  upload(refId: ID, ref: String, source: String, file: Upload!): UploadFile!
}

"""Order for clients"""
type Order {
  _id: ID!
  createdAt: DateTime!
  updatedAt: DateTime!
  dateOrder: DateTime
  user: UsersPermissionsUser
  status: ENUM_ORDER_STATUS
  products(sort: String, limit: Int, start: Int, where: JSON): [Product]
}

type OrderAggregator {
  count: Int
}

type OrderConnection {
  values: [Order]
  groupBy: OrderGroupBy
  aggregate: OrderAggregator
}

type OrderConnection_id {
  key: ID
  connection: OrderConnection
}

type OrderConnectionCreatedAt {
  key: DateTime
  connection: OrderConnection
}

type OrderConnectionDateOrder {
  key: DateTime
  connection: OrderConnection
}

type OrderConnectionStatus {
  key: String
  connection: OrderConnection
}

type OrderConnectionUpdatedAt {
  key: DateTime
  connection: OrderConnection
}

type OrderConnectionUser {
  key: ID
  connection: OrderConnection
}

type OrderGroupBy {
  _id: [OrderConnection_id]
  createdAt: [OrderConnectionCreatedAt]
  updatedAt: [OrderConnectionUpdatedAt]
  dateOrder: [OrderConnectionDateOrder]
  user: [OrderConnectionUser]
  status: [OrderConnectionStatus]
}

input OrderInput {
  dateOrder: DateTime
  products: [ID]
  user: ID
  status: ENUM_ORDER_STATUS
}

"""Product model which describe main fields of product."""
type Product {
  _id: ID!
  createdAt: DateTime!
  updatedAt: DateTime!
  name: String
  desc: String
  added_at: DateTime
  price: Float
  rating: Int
  available: Boolean
  category: Category
  sex: ENUM_PRODUCT_SEX
  discounts: Discount
  order: Order
  props: JSON
  photos(sort: String, limit: Int, start: Int, where: JSON): [UploadFile]
}

type ProductAggregator {
  count: Int
  sum: ProductAggregatorSum
  avg: ProductAggregatorAvg
  min: ProductAggregatorMin
  max: ProductAggregatorMax
}

type ProductAggregatorAvg {
  price: Float
  rating: Float
}

type ProductAggregatorMax {
  price: Float
  rating: Float
}

type ProductAggregatorMin {
  price: Float
  rating: Float
}

type ProductAggregatorSum {
  price: Float
  rating: Float
}

type ProductConnection {
  values: [Product]
  groupBy: ProductGroupBy
  aggregate: ProductAggregator
}

type ProductConnection_id {
  key: ID
  connection: ProductConnection
}

type ProductConnectionAdded_at {
  key: DateTime
  connection: ProductConnection
}

type ProductConnectionAvailable {
  key: Boolean
  connection: ProductConnection
}

type ProductConnectionCategory {
  key: ID
  connection: ProductConnection
}

type ProductConnectionCreatedAt {
  key: DateTime
  connection: ProductConnection
}

type ProductConnectionDesc {
  key: String
  connection: ProductConnection
}

type ProductConnectionDiscounts {
  key: ID
  connection: ProductConnection
}

type ProductConnectionName {
  key: String
  connection: ProductConnection
}

type ProductConnectionOrder {
  key: ID
  connection: ProductConnection
}

type ProductConnectionPrice {
  key: Float
  connection: ProductConnection
}

type ProductConnectionProps {
  key: JSON
  connection: ProductConnection
}

type ProductConnectionRating {
  key: Int
  connection: ProductConnection
}

type ProductConnectionSex {
  key: String
  connection: ProductConnection
}

type ProductConnectionUpdatedAt {
  key: DateTime
  connection: ProductConnection
}

type ProductGroupBy {
  _id: [ProductConnection_id]
  createdAt: [ProductConnectionCreatedAt]
  updatedAt: [ProductConnectionUpdatedAt]
  name: [ProductConnectionName]
  desc: [ProductConnectionDesc]
  added_at: [ProductConnectionAdded_at]
  price: [ProductConnectionPrice]
  rating: [ProductConnectionRating]
  available: [ProductConnectionAvailable]
  category: [ProductConnectionCategory]
  sex: [ProductConnectionSex]
  discounts: [ProductConnectionDiscounts]
  order: [ProductConnectionOrder]
  props: [ProductConnectionProps]
}

input ProductInput {
  name: String
  desc: String
  photos: [ID]
  added_at: DateTime
  price: Float
  rating: Int
  available: Boolean
  category: ID
  sex: ENUM_PRODUCT_SEX
  discounts: ID
  order: ID
  props: JSON
}

type Query {
  category(id: ID!): Category
  categories(sort: String, limit: Int, start: Int, where: JSON): [Category]
  categoriesConnection(sort: String, limit: Int, start: Int, where: JSON): CategoryConnection
  comment(id: ID!): Comment
  comments(sort: String, limit: Int, start: Int, where: JSON): [Comment]
  commentsConnection(sort: String, limit: Int, start: Int, where: JSON): CommentConnection
  discount(id: ID!): Discount
  discounts(sort: String, limit: Int, start: Int, where: JSON): [Discount]
  discountsConnection(sort: String, limit: Int, start: Int, where: JSON): DiscountConnection
  order(id: ID!): Order
  orders(sort: String, limit: Int, start: Int, where: JSON): [Order]
  ordersConnection(sort: String, limit: Int, start: Int, where: JSON): OrderConnection
  product(id: ID!): Product
  products(sort: String, limit: Int, start: Int, where: JSON): [Product]
  productsConnection(sort: String, limit: Int, start: Int, where: JSON): ProductConnection
  slidercontent(id: ID!): Slidercontent
  slidercontents(sort: String, limit: Int, start: Int, where: JSON): [Slidercontent]
  slidercontentsConnection(sort: String, limit: Int, start: Int, where: JSON): SlidercontentConnection
  files(sort: String, limit: Int, start: Int, where: JSON): [UploadFile]
  filesConnection(sort: String, limit: Int, start: Int, where: JSON): UploadFileConnection
  role(id: ID!): UsersPermissionsRole

  """
  Retrieve all the existing roles. You can't apply filters on this query.
  """
  roles(sort: String, limit: Int, start: Int, where: JSON): [UsersPermissionsRole]
  rolesConnection(sort: String, limit: Int, start: Int, where: JSON): UsersPermissionsRoleConnection
  user(id: ID!): UsersPermissionsUser
  users(sort: String, limit: Int, start: Int, where: JSON): [UsersPermissionsUser]
  usersConnection(sort: String, limit: Int, start: Int, where: JSON): UsersPermissionsUserConnection
  me: UsersPermissionsMe
}

input RoleInput {
  name: String!
  description: String
  type: String
  permissions: [ID]
  users: [ID]
}

type Slidercontent {
  _id: ID!
  createdAt: DateTime!
  updatedAt: DateTime!
  name: String
  image: UploadFile
  link: String
}

type SlidercontentAggregator {
  count: Int
}

type SlidercontentConnection {
  values: [Slidercontent]
  groupBy: SlidercontentGroupBy
  aggregate: SlidercontentAggregator
}

type SlidercontentConnection_id {
  key: ID
  connection: SlidercontentConnection
}

type SlidercontentConnectionCreatedAt {
  key: DateTime
  connection: SlidercontentConnection
}

type SlidercontentConnectionImage {
  key: ID
  connection: SlidercontentConnection
}

type SlidercontentConnectionLink {
  key: String
  connection: SlidercontentConnection
}

type SlidercontentConnectionName {
  key: String
  connection: SlidercontentConnection
}

type SlidercontentConnectionUpdatedAt {
  key: DateTime
  connection: SlidercontentConnection
}

type SlidercontentGroupBy {
  _id: [SlidercontentConnection_id]
  createdAt: [SlidercontentConnectionCreatedAt]
  updatedAt: [SlidercontentConnectionUpdatedAt]
  name: [SlidercontentConnectionName]
  image: [SlidercontentConnectionImage]
  link: [SlidercontentConnectionLink]
}

input SlidercontentInput {
  name: String
  image: ID
  link: String
}

input updateCategoryInput {
  where: InputID
  data: editCategoryInput
}

type updateCategoryPayload {
  category: Category
}

input updateCommentInput {
  where: InputID
  data: editCommentInput
}

type updateCommentPayload {
  comment: Comment
}

input updateDiscountInput {
  where: InputID
  data: editDiscountInput
}

type updateDiscountPayload {
  discount: Discount
}

input updateOrderInput {
  where: InputID
  data: editOrderInput
}

type updateOrderPayload {
  order: Order
}

input updateProductInput {
  where: InputID
  data: editProductInput
}

type updateProductPayload {
  product: Product
}

input updateRoleInput {
  where: InputID
  data: editRoleInput
}

type updateRolePayload {
  role: UsersPermissionsRole
}

input updateSlidercontentInput {
  where: InputID
  data: editSlidercontentInput
}

type updateSlidercontentPayload {
  slidercontent: Slidercontent
}

input updateUserInput {
  where: InputID
  data: editUserInput
}

type updateUserPayload {
  user: UsersPermissionsUser
}

"""The `Upload` scalar type represents a file upload."""
scalar Upload

type UploadFile {
  _id: ID!
  createdAt: DateTime!
  updatedAt: DateTime!
  name: String!
  hash: String!
  sha256: String
  ext: String
  mime: String!
  size: String!
  url: String!
  provider: String!
  public_id: String
  related(sort: String, limit: Int, start: Int, where: JSON): [Morph]
}

type UploadFileAggregator {
  count: Int
}

type UploadFileConnection {
  values: [UploadFile]
  groupBy: UploadFileGroupBy
  aggregate: UploadFileAggregator
}

type UploadFileConnection_id {
  key: ID
  connection: UploadFileConnection
}

type UploadFileConnectionCreatedAt {
  key: DateTime
  connection: UploadFileConnection
}

type UploadFileConnectionExt {
  key: String
  connection: UploadFileConnection
}

type UploadFileConnectionHash {
  key: String
  connection: UploadFileConnection
}

type UploadFileConnectionMime {
  key: String
  connection: UploadFileConnection
}

type UploadFileConnectionName {
  key: String
  connection: UploadFileConnection
}

type UploadFileConnectionProvider {
  key: String
  connection: UploadFileConnection
}

type UploadFileConnectionPublic_id {
  key: String
  connection: UploadFileConnection
}

type UploadFileConnectionSha256 {
  key: String
  connection: UploadFileConnection
}

type UploadFileConnectionSize {
  key: String
  connection: UploadFileConnection
}

type UploadFileConnectionUpdatedAt {
  key: DateTime
  connection: UploadFileConnection
}

type UploadFileConnectionUrl {
  key: String
  connection: UploadFileConnection
}

type UploadFileGroupBy {
  _id: [UploadFileConnection_id]
  createdAt: [UploadFileConnectionCreatedAt]
  updatedAt: [UploadFileConnectionUpdatedAt]
  name: [UploadFileConnectionName]
  hash: [UploadFileConnectionHash]
  sha256: [UploadFileConnectionSha256]
  ext: [UploadFileConnectionExt]
  mime: [UploadFileConnectionMime]
  size: [UploadFileConnectionSize]
  url: [UploadFileConnectionUrl]
  provider: [UploadFileConnectionProvider]
  public_id: [UploadFileConnectionPublic_id]
}

input UserInput {
  username: String!
  email: String!
  provider: String
  password: String
  resetPasswordToken: String
  confirmed: Boolean
  blocked: Boolean
  role: ID
  order: [ID]
  comment: ID
  address: JSON
  name: String
  surname: String
}

type UsersPermissionsMe {
  _id: ID!
  username: String!
  email: String!
  confirmed: Boolean
  blocked: Boolean
  role: UsersPermissionsMeRole
}

type UsersPermissionsMeRole {
  _id: ID!
  name: String!
  description: String
  type: String
}

type UsersPermissionsPermission {
  _id: ID!
  type: String!
  controller: String!
  action: String!
  enabled: Boolean!
  policy: String
  role: UsersPermissionsRole
}

type UsersPermissionsRole {
  _id: ID!
  name: String!
  description: String
  type: String
  permissions(sort: String, limit: Int, start: Int, where: JSON): [UsersPermissionsPermission]
  users(sort: String, limit: Int, start: Int, where: JSON): [UsersPermissionsUser]
}

type UsersPermissionsRoleAggregator {
  count: Int
}

type UsersPermissionsRoleConnection {
  values: [UsersPermissionsRole]
  groupBy: UsersPermissionsRoleGroupBy
  aggregate: UsersPermissionsRoleAggregator
}

type UsersPermissionsRoleConnection_id {
  key: ID
  connection: UsersPermissionsRoleConnection
}

type UsersPermissionsRoleConnectionDescription {
  key: String
  connection: UsersPermissionsRoleConnection
}

type UsersPermissionsRoleConnectionName {
  key: String
  connection: UsersPermissionsRoleConnection
}

type UsersPermissionsRoleConnectionType {
  key: String
  connection: UsersPermissionsRoleConnection
}

type UsersPermissionsRoleGroupBy {
  _id: [UsersPermissionsRoleConnection_id]
  name: [UsersPermissionsRoleConnectionName]
  description: [UsersPermissionsRoleConnectionDescription]
  type: [UsersPermissionsRoleConnectionType]
}

type UsersPermissionsUser {
  _id: ID!
  username: String!
  email: String!
  provider: String
  confirmed: Boolean
  blocked: Boolean
  role: UsersPermissionsRole
  comment: Comment
  address: JSON
  name: String
  surname: String
  order(sort: String, limit: Int, start: Int, where: JSON): [Order]
}

type UsersPermissionsUserAggregator {
  count: Int
}

type UsersPermissionsUserConnection {
  values: [UsersPermissionsUser]
  groupBy: UsersPermissionsUserGroupBy
  aggregate: UsersPermissionsUserAggregator
}

type UsersPermissionsUserConnection_id {
  key: ID
  connection: UsersPermissionsUserConnection
}

type UsersPermissionsUserConnectionAddress {
  key: JSON
  connection: UsersPermissionsUserConnection
}

type UsersPermissionsUserConnectionBlocked {
  key: Boolean
  connection: UsersPermissionsUserConnection
}

type UsersPermissionsUserConnectionComment {
  key: ID
  connection: UsersPermissionsUserConnection
}

type UsersPermissionsUserConnectionConfirmed {
  key: Boolean
  connection: UsersPermissionsUserConnection
}

type UsersPermissionsUserConnectionEmail {
  key: String
  connection: UsersPermissionsUserConnection
}

type UsersPermissionsUserConnectionName {
  key: String
  connection: UsersPermissionsUserConnection
}

type UsersPermissionsUserConnectionProvider {
  key: String
  connection: UsersPermissionsUserConnection
}

type UsersPermissionsUserConnectionRole {
  key: ID
  connection: UsersPermissionsUserConnection
}

type UsersPermissionsUserConnectionSurname {
  key: String
  connection: UsersPermissionsUserConnection
}

type UsersPermissionsUserConnectionUsername {
  key: String
  connection: UsersPermissionsUserConnection
}

type UsersPermissionsUserGroupBy {
  _id: [UsersPermissionsUserConnection_id]
  username: [UsersPermissionsUserConnectionUsername]
  email: [UsersPermissionsUserConnectionEmail]
  provider: [UsersPermissionsUserConnectionProvider]
  confirmed: [UsersPermissionsUserConnectionConfirmed]
  blocked: [UsersPermissionsUserConnectionBlocked]
  role: [UsersPermissionsUserConnectionRole]
  comment: [UsersPermissionsUserConnectionComment]
  address: [UsersPermissionsUserConnectionAddress]
  name: [UsersPermissionsUserConnectionName]
  surname: [UsersPermissionsUserConnectionSurname]
}
